<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Projeto DA 2: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Projeto DA 2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a902c5b3eacb66d60752525ab23297a95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a902c5b3eacb66d60752525ab23297a95">~Graph</a> ()</td></tr>
<tr class="separator:a902c5b3eacb66d60752525ab23297a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46dcb9c77cd9059a139d482940c796d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a46dcb9c77cd9059a139d482940c796d3">findNode</a> (const int &amp;id) const</td></tr>
<tr class="separator:a46dcb9c77cd9059a139d482940c796d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41ff5ab9cb4ba4ef492b7f2c4e72717"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae41ff5ab9cb4ba4ef492b7f2c4e72717">addNode</a> (const int &amp;id, double longitude=0, double latitude=0)</td></tr>
<tr class="separator:ae41ff5ab9cb4ba4ef492b7f2c4e72717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48074436e005feac5fac47e42e97c67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa48074436e005feac5fac47e42e97c67">getNumNode</a> () const</td></tr>
<tr class="separator:aa48074436e005feac5fac47e42e97c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab252b7e4456aeb7c60a43be11630bb00"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ab252b7e4456aeb7c60a43be11630bb00">getNodeSet</a> () const</td></tr>
<tr class="separator:ab252b7e4456aeb7c60a43be11630bb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ea0d41e669493235b2505adb014057"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a64ea0d41e669493235b2505adb014057">sortNodes</a> ()</td></tr>
<tr class="separator:a64ea0d41e669493235b2505adb014057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9d70013c2acf9038596792edbd1ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a2f9d70013c2acf9038596792edbd1ec5">sortEdges</a> ()</td></tr>
<tr class="separator:a2f9d70013c2acf9038596792edbd1ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516f4487d70f4b15e413447afa8c2310"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a516f4487d70f4b15e413447afa8c2310">addEdge</a> (const int &amp;sourc, const int &amp;dest, double w)</td></tr>
<tr class="separator:a516f4487d70f4b15e413447afa8c2310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6b6b10ebe49cc0191ab45151cd49e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a5d6b6b10ebe49cc0191ab45151cd49e7">addBidirectionalEdge</a> (const int &amp;sourc, const int &amp;dest, double w)</td></tr>
<tr class="separator:a5d6b6b10ebe49cc0191ab45151cd49e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee17f9865abe0de32b3daee62c3c1b42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aee17f9865abe0de32b3daee62c3c1b42">cleanGraph</a> ()</td></tr>
<tr class="separator:aee17f9865abe0de32b3daee62c3c1b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442f159eb669e072165392704864b7cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a442f159eb669e072165392704864b7cd">calculateMissingToyDistances</a> ()</td></tr>
<tr class="separator:a442f159eb669e072165392704864b7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbb021cbaf6a916083627f898e307e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a6dbb021cbaf6a916083627f898e307e3">zeroHasNoEdgesLeft</a> ()</td></tr>
<tr class="separator:a6dbb021cbaf6a916083627f898e307e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271f1fe38e931ced533a73cbc51f95e6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a271f1fe38e931ced533a73cbc51f95e6">tspBTRec</a> (std::vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; &amp;path, double min, double curCost, unsigned int i, unsigned int curPathSize, bool ended)</td></tr>
<tr class="separator:a271f1fe38e931ced533a73cbc51f95e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4965fa94e4e14ada673db2046b53a3cf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a4965fa94e4e14ada673db2046b53a3cf">tspBT</a> (std::vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; &amp;path)</td></tr>
<tr class="separator:a4965fa94e4e14ada673db2046b53a3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07536cab1c52f5aa372ca301b01c4954"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a07536cab1c52f5aa372ca301b01c4954">preOrder</a> (<a class="el" href="class_node.html">Node</a> *node, std::vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; &amp;mst, bool firstIt, double &amp;weight, const string &amp;ex)</td></tr>
<tr class="separator:a07536cab1c52f5aa372ca301b01c4954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32be3a6726ef44df4e0d41683d051b55"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a32be3a6726ef44df4e0d41683d051b55">TriangularApproximationHeuristic</a> (vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; nodeSet, std::vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; &amp;mst, const std::string &amp;type, const std::string &amp;ex)</td></tr>
<tr class="separator:a32be3a6726ef44df4e0d41683d051b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818dfec6a108ff92bac49fc83559f2af"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a818dfec6a108ff92bac49fc83559f2af">kruskal</a> ()</td></tr>
<tr class="separator:a818dfec6a108ff92bac49fc83559f2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d4976ab98e0261ca9659659a8b59b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a13d4976ab98e0261ca9659659a8b59b1">dfsKruskalPath</a> (<a class="el" href="class_node.html">Node</a> *v)</td></tr>
<tr class="separator:a13d4976ab98e0261ca9659659a8b59b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbebfe07a97cd88eec79b4cbc2764445"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#acbebfe07a97cd88eec79b4cbc2764445">kruskalEx3</a> (vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; &amp;nodeSet)</td></tr>
<tr class="separator:acbebfe07a97cd88eec79b4cbc2764445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc89c9e49148b2368425f0b3046c439"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a6fc89c9e49148b2368425f0b3046c439">kMeansDivideAndConquer</a> (int k, std::vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; clusters, double &amp;totalMin, bool firstIt)</td></tr>
<tr class="separator:a6fc89c9e49148b2368425f0b3046c439"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a63bd22d689fa71accfd714a28ecdc644"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a63bd22d689fa71accfd714a28ecdc644">getEdgeWeight</a> (<a class="el" href="class_node.html">Node</a> *first, <a class="el" href="class_node.html">Node</a> *second)</td></tr>
<tr class="separator:a63bd22d689fa71accfd714a28ecdc644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29aeb5bfe8776d845aaa7ccc5cc746a"><td class="memItemLeft" align="right" valign="top">static vector&lt; <a class="el" href="class_node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae29aeb5bfe8776d845aaa7ccc5cc746a">joinSolvedTSP</a> (std::vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; solved, std::vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; add, double &amp;weight)</td></tr>
<tr class="separator:ae29aeb5bfe8776d845aaa7ccc5cc746a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b70a2f1f7529abfde56fcb401aedc2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a74b70a2f1f7529abfde56fcb401aedc2">makeClusters</a> (const std::vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; &amp;centroids, vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; &amp;cluster)</td></tr>
<tr class="separator:a74b70a2f1f7529abfde56fcb401aedc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e3438b61f5f74a3b4d60c68cbcc267"><td class="memItemLeft" align="right" valign="top">static vector&lt; <a class="el" href="class_node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a46e3438b61f5f74a3b4d60c68cbcc267">getCentroidCluster</a> (<a class="el" href="class_node.html">Node</a> *centroid, vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; const &amp;cluster)</td></tr>
<tr class="separator:a46e3438b61f5f74a3b4d60c68cbcc267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94fff9fa0d4cf05e3593d2999a2d0e1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#af94fff9fa0d4cf05e3593d2999a2d0e1">haveSimilarDistance</a> (const vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; &amp;cluster)</td></tr>
<tr class="separator:af94fff9fa0d4cf05e3593d2999a2d0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a77d4b80fea3603f2414f135e15a22b57"><td class="memItemLeft" align="right" valign="top"><a id="a77d4b80fea3603f2414f135e15a22b57" name="a77d4b80fea3603f2414f135e15a22b57"></a>
std::vector&lt; <a class="el" href="class_node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeSet</b></td></tr>
<tr class="separator:a77d4b80fea3603f2414f135e15a22b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e61864da69191c1896a25a708d1a02d"><td class="memItemLeft" align="right" valign="top"><a id="a9e61864da69191c1896a25a708d1a02d" name="a9e61864da69191c1896a25a708d1a02d"></a>
double **&#160;</td><td class="memItemRight" valign="bottom"><b>distMatrix</b> = nullptr</td></tr>
<tr class="separator:a9e61864da69191c1896a25a708d1a02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae09699c3616af3ebfcb1eb045f2b62"><td class="memItemLeft" align="right" valign="top"><a id="a3ae09699c3616af3ebfcb1eb045f2b62" name="a3ae09699c3616af3ebfcb1eb045f2b62"></a>
int **&#160;</td><td class="memItemRight" valign="bottom"><b>pathMatrix</b> = nullptr</td></tr>
<tr class="separator:a3ae09699c3616af3ebfcb1eb045f2b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a902c5b3eacb66d60752525ab23297a95" name="a902c5b3eacb66d60752525ab23297a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902c5b3eacb66d60752525ab23297a95">&#9670;&#160;</a></span>~Graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::~Graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default destructor of the <a class="el" href="class_graph.html">Graph</a> class. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5d6b6b10ebe49cc0191ab45151cd49e7" name="a5d6b6b10ebe49cc0191ab45151cd49e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6b6b10ebe49cc0191ab45151cd49e7">&#9670;&#160;</a></span>addBidirectionalEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addBidirectionalEdge </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>sourc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a bidirectional edge to the (this) graph, with origin, destination and weight passed as parameters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourc</td><td>Represents one of the nodes of the edge </td></tr>
    <tr><td class="paramname">dest</td><td>Represents one of the nodes of the edge </td></tr>
    <tr><td class="paramname">w</td><td>Represents the weight of the edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an edge with that information doesn't exist in the NodeSet, false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(V) with V being the size of the NodeSet </dd></dl>

</div>
</div>
<a id="a516f4487d70f4b15e413447afa8c2310" name="a516f4487d70f4b15e413447afa8c2310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516f4487d70f4b15e413447afa8c2310">&#9670;&#160;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>sourc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds an edge to the (this) graph, with origin, destination and weight passed as parameters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourc</td><td>Represents the origin of the edge </td></tr>
    <tr><td class="paramname">dest</td><td>Represents the destination of the edge </td></tr>
    <tr><td class="paramname">w</td><td>Represents the weight of the edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an edge with that information doesn't exist in the NodeSet, false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(V) with V being the size of the NodeSet </dd></dl>

</div>
</div>
<a id="ae41ff5ab9cb4ba4ef492b7f2c4e72717" name="ae41ff5ab9cb4ba4ef492b7f2c4e72717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41ff5ab9cb4ba4ef492b7f2c4e72717">&#9670;&#160;</a></span>addNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addNode </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>longitude</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>latitude</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a node with id, longitude and latitude passed as parameter to the NodeSet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Represents the id of the node to be added </td></tr>
    <tr><td class="paramname">longitude</td><td>Represents the longitude of the node to be added. Default is 0 </td></tr>
    <tr><td class="paramname">latitude</td><td>Represents the latitude of the node to be added. Default is 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the node with those values does not exist in the NodeSet, false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(V) with V being the size of the NodeSet </dd></dl>

</div>
</div>
<a id="a442f159eb669e072165392704864b7cd" name="a442f159eb669e072165392704864b7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442f159eb669e072165392704864b7cd">&#9670;&#160;</a></span>calculateMissingToyDistances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::calculateMissingToyDistances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates and adds the missing edges to turn a toy graph into a fully connected graph. Bases the calculations on the triangular inequality property, the sum of the lengths of any two sides must be greater than or equal to the length of the remaining side. </p><dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(V^2 * U) where U is the number of nodes not fully connected </dd></dl>

</div>
</div>
<a id="aee17f9865abe0de32b3daee62c3c1b42" name="aee17f9865abe0de32b3daee62c3c1b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee17f9865abe0de32b3daee62c3c1b42">&#9670;&#160;</a></span>cleanGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::cleanGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the nodes and edges of the (this) graph. </p><dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(V+E) with V being the size of the NodeSet and E being the number of edges of each node </dd></dl>

</div>
</div>
<a id="a13d4976ab98e0261ca9659659a8b59b1" name="a13d4976ab98e0261ca9659659a8b59b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d4976ab98e0261ca9659659a8b59b1">&#9670;&#160;</a></span>dfsKruskalPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::dfsKruskalPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Depth-first Search used in the implementation of the kruskal algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Represents a node which edges will be used in the DFS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(E) where E is the number of edges of the v node </dd></dl>

</div>
</div>
<a id="a46dcb9c77cd9059a139d482940c796d3" name="a46dcb9c77cd9059a139d482940c796d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46dcb9c77cd9059a139d482940c796d3">&#9670;&#160;</a></span>findNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> * Graph::findNode </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loops through the NodeSet to check if a node with the id given as parameter exists. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Represents the id of the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Node* if it exists in the NodeSet, nullptr otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(V) with V being the size of the NodeSet </dd></dl>

</div>
</div>
<a id="a46e3438b61f5f74a3b4d60c68cbcc267" name="a46e3438b61f5f74a3b4d60c68cbcc267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e3438b61f5f74a3b4d60c68cbcc267">&#9670;&#160;</a></span>getCentroidCluster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; Graph::getCentroidCluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cluster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the cluster of a centroid </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">centroid</td><td>Represents the centroid of a cluster </td></tr>
    <tr><td class="paramname">cluster</td><td>Represents a cluster of nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&amp;lt Node*&gt; with every node pertaining to the cluster of a centroid </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(n) with n being the size of the cluster vector </dd></dl>

</div>
</div>
<a id="a63bd22d689fa71accfd714a28ecdc644" name="a63bd22d689fa71accfd714a28ecdc644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bd22d689fa71accfd714a28ecdc644">&#9670;&#160;</a></span>getEdgeWeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::getEdgeWeight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the weight of the edge between the two nodes passed as parameters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Represents one of the nodes of the edge </td></tr>
    <tr><td class="paramname">second</td><td>Represents one of the nodes of the edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The weight of the edge if it exists, INF otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(E) with E being the number of outgoing edges of the first node </dd></dl>

</div>
</div>
<a id="ab252b7e4456aeb7c60a43be11630bb00" name="ab252b7e4456aeb7c60a43be11630bb00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab252b7e4456aeb7c60a43be11630bb00">&#9670;&#160;</a></span>getNodeSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; Graph::getNodeSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the vector NodeSet of the (this) graph. </p><dl class="section return"><dt>Returns</dt><dd>vector with the nodes belonging to the (this) graph </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(1) </dd></dl>

</div>
</div>
<a id="aa48074436e005feac5fac47e42e97c67" name="aa48074436e005feac5fac47e42e97c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48074436e005feac5fac47e42e97c67">&#9670;&#160;</a></span>getNumNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::getNumNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of nodes in the (this) graph. </p><dl class="section return"><dt>Returns</dt><dd>The size of the NodeSet </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(1) </dd></dl>

</div>
</div>
<a id="af94fff9fa0d4cf05e3593d2999a2d0e1" name="af94fff9fa0d4cf05e3593d2999a2d0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94fff9fa0d4cf05e3593d2999a2d0e1">&#9670;&#160;</a></span>haveSimilarDistance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::haveSimilarDistance </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the nodes of a cluster have similar distance by analysing the mean and standard deviation of their distances. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster</td><td>Represents a cluster of nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the standard deviation is less or equal than 10% of the mean of the nodes' distances </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(1) </dd></dl>

</div>
</div>
<a id="ae29aeb5bfe8776d845aaa7ccc5cc746a" name="ae29aeb5bfe8776d845aaa7ccc5cc746a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29aeb5bfe8776d845aaa7ccc5cc746a">&#9670;&#160;</a></span>joinSolvedTSP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; Graph::joinSolvedTSP </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_node.html">Node</a> * &gt;&#160;</td>
          <td class="paramname"><em>solved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_node.html">Node</a> * &gt;&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the best nodes to link two clusters with solved hamiltonian cycles and merges the two clusters. Stores the weight of the hamiltonian cycle in the variable weight passed as parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solved</td><td>Represents one of the clusters to be merged </td></tr>
    <tr><td class="paramname">add</td><td>Represents one of the clusters to be merged </td></tr>
    <tr><td class="paramname">weight</td><td>Represents the weight of the hamiltonian cycle of the merged clusters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Merged cluster of the solved and add clusters </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(S * A + S + A) with S being the size of solved vector and A the size of the add vector </dd></dl>

</div>
</div>
<a id="a6fc89c9e49148b2368425f0b3046c439" name="a6fc89c9e49148b2368425f0b3046c439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc89c9e49148b2368425f0b3046c439">&#9670;&#160;</a></span>kMeansDivideAndConquer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; Graph::kMeansDivideAndConquer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_node.html">Node</a> * &gt;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>totalMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>firstIt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of the k-means algorithm using a divide and conquer approach. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Represents the number of clusters created in each iteration of this algorithm </td></tr>
    <tr><td class="paramname">clusters</td><td>Represents the current cluster of nodes </td></tr>
    <tr><td class="paramname">totalMin</td><td>Represents the total weight of the path of the clusters variable </td></tr>
    <tr><td class="paramname">firstIt</td><td>Checks if the function is in its first iteration. True if it is, false otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The path solved by the approximation heuristic </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O((C + K * C) * log(K)) with C being the size of the clusters vector and K the size of the centroids vector </dd></dl>

</div>
</div>
<a id="a818dfec6a108ff92bac49fc83559f2af" name="a818dfec6a108ff92bac49fc83559f2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818dfec6a108ff92bac49fc83559f2af">&#9670;&#160;</a></span>kruskal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::kruskal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of the kruskal algorithm. Creates an MST and returns the sum of the weight of the selected edges. </p><dl class="section return"><dt>Returns</dt><dd>The sum of the weight of the edges of the MST </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(N*E + E*log(E)), where N is the number of nodes and E is the number of edges </dd></dl>

</div>
</div>
<a id="acbebfe07a97cd88eec79b4cbc2764445" name="acbebfe07a97cd88eec79b4cbc2764445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbebfe07a97cd88eec79b4cbc2764445">&#9670;&#160;</a></span>kruskalEx3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::kruskalEx3 </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of the kruskal algorithm, specific to the 3rd exercise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSet</td><td>Represents a cluster of nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the weight of the edges of the MST </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(N*E + E*log(E)), where N is the number of nodes and E is the number of edges </dd></dl>

</div>
</div>
<a id="a74b70a2f1f7529abfde56fcb401aedc2" name="a74b70a2f1f7529abfde56fcb401aedc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b70a2f1f7529abfde56fcb401aedc2">&#9670;&#160;</a></span>makeClusters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::makeClusters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates clusters with a centroid in the center of each cluster. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">centroids</td><td>Represents the centroids created randomly </td></tr>
    <tr><td class="paramname">cluster</td><td>Represents the cluster in which the clusters will be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(C + K * C) with C being the size of the cluster vector and K the size of the centroids vector </dd></dl>

</div>
</div>
<a id="a07536cab1c52f5aa372ca301b01c4954" name="a07536cab1c52f5aa372ca301b01c4954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07536cab1c52f5aa372ca301b01c4954">&#9670;&#160;</a></span>preOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::preOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>firstIt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>ex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an MST by visiting the (this) graph in preOrder, starting with the node provided as parameter. Stores the sum of the edges of the MST in the weight variable passed as parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Represents the first node to be visited </td></tr>
    <tr><td class="paramname">mst</td><td>Represents the nodes belonging to the MST </td></tr>
    <tr><td class="paramname">firstIt</td><td>Checks if the function is in its first iteration. True if it is, false otherwise </td></tr>
    <tr><td class="paramname">weight</td><td>Represents the sum of the edges of the MST </td></tr>
    <tr><td class="paramname">ex</td><td>Represents which exercise this function is being used for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(E+N) with E being the outgoing edges of the node parameter and N the number of nodes in the graph </dd></dl>

</div>
</div>
<a id="a2f9d70013c2acf9038596792edbd1ec5" name="a2f9d70013c2acf9038596792edbd1ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9d70013c2acf9038596792edbd1ec5">&#9670;&#160;</a></span>sortEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::sortEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the edges of the (this) graph from lowest to highest </p><dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(n*log(n)) </dd></dl>

</div>
</div>
<a id="a64ea0d41e669493235b2505adb014057" name="a64ea0d41e669493235b2505adb014057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ea0d41e669493235b2505adb014057">&#9670;&#160;</a></span>sortNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::sortNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the nodes of the (this) graph from lowest to highest </p><dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(n*log(n)) </dd></dl>

</div>
</div>
<a id="a32be3a6726ef44df4e0d41683d051b55" name="a32be3a6726ef44df4e0d41683d051b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32be3a6726ef44df4e0d41683d051b55">&#9670;&#160;</a></span>TriangularApproximationHeuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::TriangularApproximationHeuristic </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_node.html">Node</a> * &gt;&#160;</td>
          <td class="paramname"><em>nodeSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of the triangular approximation heuristic. Utilizes the triangular inequality law to approximate a value close to the optimal one, in return for more efficiency. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSet</td><td>Represents the NodeSet of the (this) graph </td></tr>
    <tr><td class="paramname">mst</td><td>Represents the nodes belonging to the MST </td></tr>
    <tr><td class="paramname">type</td><td>Represents the type of graph </td></tr>
    <tr><td class="paramname">ex</td><td>Represents which exercise this function is being used for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The weight of the path taken </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(N*E + E*log(E)), where N is the size of the nodeSet vector and E is the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="a4965fa94e4e14ada673db2046b53a3cf" name="a4965fa94e4e14ada673db2046b53a3cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4965fa94e4e14ada673db2046b53a3cf">&#9670;&#160;</a></span>tspBT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::tspBT </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills the vector path with the size of the NodeSet and initialises it with 0's, also iterates over the NodeSet and sets every node's visited field as false. Returns the result of the tspBTRec, a.k.a the recursive function that implements the backtracking algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Is initially sent as an empty vector. At the end of the function call, represents the optimal path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The weight of the optimal path </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O((n-1)!*E) with n being the number of nodes in the graph </dd></dl>

</div>
</div>
<a id="a271f1fe38e931ced533a73cbc51f95e6" name="a271f1fe38e931ced533a73cbc51f95e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271f1fe38e931ced533a73cbc51f95e6">&#9670;&#160;</a></span>tspBTRec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::tspBTRec </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>curCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>curPathSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ended</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of the backtracking algorithm. Calculates the optimal path for the (this) graph and returns the weight of said path. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Represents the path taken </td></tr>
    <tr><td class="paramname">min</td><td>Represents the minimum cost of the paths travelled so far </td></tr>
    <tr><td class="paramname">curCost</td><td>Represents the current cost of the path taken </td></tr>
    <tr><td class="paramname">i</td><td>Represents the id of the node </td></tr>
    <tr><td class="paramname">curPathSize</td><td>Represents the current path size </td></tr>
    <tr><td class="paramname">ended</td><td>Checks if the end of the path has been reached </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum cost of the paths travelled </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O((n-1)!*E) with n being the number of nodes in the graph </dd></dl>

</div>
</div>
<a id="a6dbb021cbaf6a916083627f898e307e3" name="a6dbb021cbaf6a916083627f898e307e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dbb021cbaf6a916083627f898e307e3">&#9670;&#160;</a></span>zeroHasNoEdgesLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::zeroHasNoEdgesLeft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if node 0 has any adjacent edge that is yet to be visited. </p><dl class="section return"><dt>Returns</dt><dd>False if it finds any unvisited node, true otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Time-complexity -&gt; O(E) with E being the number of outgoing edges from node 0 </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>src/Graph.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
